# Tactics Programming

tags: dependent-types, tactics, learning, metaprogramming

It seems like entering tactics mode is much like entering a Template Haskell splice.
That is, the tactic language is a EDSL in the `Q` monad.
In particular, the a tactic block needs:
  * to know the type expected for a program the block must generate, which I think can be provided by reification
  * the types of in-scope bindings, which I know is available through reification
  * to be able to create new type variables, which is available in TH
  * to be able to unify reified types, which at least could be exposed in the `Q` monad
  * when a tactic creates some program, it may contain holes; these need to be extracted and used to set new goals, which could be done with standard AST traversals available from template programming
  * otherwise, many combinators are just `>>`, `mapM`, `<|>`, or something like `iterateM` (i.e. a repeat combinator)

Let's say that I'm right, and tactics are just a particular form of metaprogramming.
Well then, that would give be a better idea of how to understand Coq.

## Wingman

I watched a talk on this software today.
It's a Haskell Language Server plugin that allows you to write in a tactic language.
Then, a command replaces the source text of the tactic with generated Haskell source.

On the one hand, this is really nice because when you go back to read the code, you just understand the code because it's normal code:
  you don't have to decipher the path through the maze of goals that the original author took.
On the other hand, the generated code sometimes doesn't describe the intention very well:
  if a term was generated by just soling a ring equation, I want to read `ring`, not the generated maze of association, commutation, identities, and whatnot.

A key takeaway for me was this (I'm just quoting myself here):
  > Idioms indicate deficiencies in the abstractive or expressive power of the language.
  > And now that I think about it, Haskell has all sorts of deficiencies that tactics could eliminate.

## The Implications for HoTT

Tactics blocks—being metaprograms that often perform proof search—can take a long time to compute.
It would be a shame if an unrelated change in a dependency caused the tactic to have to perform a long search again ,only to come to the same proof that was found last time.
Therefore, the results of tactic solutions should be cached:
  if a tactic block is to be evaluated, first check if the cached solution still works, and only if it does not does the tactic need to be executed.

I—and I expect others—write code non-linearly.
Thus, I need to be able to write proofs that depend on earlier unproven theorems.
Obviously, compilation as a whole should fail if parts of a program are `undefined`, but typechecking should be able to continue into later definitions, even if they depend on undefined values (as long as the type is complete).

I almost certainly need to pay more attention to Template Haskell, and possibly also the typed expression types that have been added of late.
It's a little bit of a pain what with GHC's internal AST changing, and not quite yet being unified with TH's AST type, but
  it's well worth it if Wingman could be just normal TH instead of a HLS plugin.

There's also the question of typesetting tactics programs to both look mathematical, and look programmatical.
I think typesetting as Fitch-style proofs (or some variant that reduces duplication) may be useful here.
The LHS can be a partial proof (with holes (linking to the expression that fills the hole)).
The RHS can be the written tactic.
Thankfully, Fitch proofs are naturally organized as nested sections, allowing section collapsing.
